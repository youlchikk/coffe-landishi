{
  "coffe-app/packages/EPPlus.7.5.1/license.html": {
    "href": "coffe-app/packages/EPPlus.7.5.1/license.html",
    "title": "Polyform Noncommercial License 1.0.0 | coffe-landishi",
    "keywords": "Polyform Noncommercial License 1.0.0 https://polyformproject.org/licenses/noncommercial/1.0.0 Acceptance In order to get any license under these terms, you must agree to them as both strict obligations and conditions to all your licenses. Copyright License The licensor grants you a copyright license for the software to do everything you might do with the software that would otherwise infringe the licensor's copyright in it for any permitted purpose. However, you may only distribute the software according to Distribution License and make changes or new works based on the software according to Changes and New Works License. Distribution License The licensor grants you an additional copyright license to distribute copies of the software. Your license to distribute covers distributing the software with changes and new works permitted by Changes and New Works License. Notices You must ensure that anyone who gets a copy of any part of the software from you also gets a copy of these terms or the URL for them above, as well as copies of any plain-text lines beginning with Required Notice: that the licensor provided with the software. For example: Required Notice: Copyright Yoyodyne, Inc. (http://example.com) Changes and New Works License The licensor grants you an additional copyright license to make changes and new works based on the software for any permitted purpose. Patent License The licensor grants you a patent license for the software that covers patent claims the licensor can license, or becomes able to license, that you would infringe by using the software. Noncommercial Purposes Any noncommercial purpose is a permitted purpose. Personal Uses Personal use for research, experiment, and testing for the benefit of public knowledge, personal study, private entertainment, hobby projects, amateur pursuits, or religious observance, without any anticipated commercial application, is use for a permitted purpose. Noncommercial Organizations Use by any charitable organization, educational institution, public research organization, public safety or health organization, environmental protection organization, or government institution is use for a permitted purpose regardless of the source of funding or obligations resulting from the funding. Fair Use You may have \"fair use\" rights for the software under the law. These terms do not limit them. No Other Rights These terms do not allow you to sublicense or transfer any of your licenses to anyone else, or prevent the licensor from granting licenses to anyone else. These terms do not imply any other licenses. Patent Defense If you make any written claim that the software infringes or contributes to infringement of any patent, your patent license for the software granted under these terms ends immediately. If your company makes such a claim, your patent license ends immediately for work on behalf of your company. Violations The first time you are notified in writing that you have violated any of these terms, or done anything with the software not covered by your licenses, your licenses can nonetheless continue if you come into full compliance with these terms, and take practical steps to correct past violations, within 32 days of receiving notice. Otherwise, all your licenses end immediately. No Liability As far as the law allows, the software comes as is, without any warranty or condition, and the licensor will not be liable to you for any damages arising out of these terms or the use or nature of the software, under any kind of legal claim. Definitions The licensor is the individual or entity offering these terms, and the software is the software the licensor makes available under these terms. You refers to the individual or entity agreeing to these terms. Your company is any legal entity, sole proprietorship, or other kind of organization that you work for, plus all organizations that have control over, are under the control of, or are under common control with that organization. Control means ownership of substantially all the assets of an entity, or the power to direct its management and policies by vote, contract, or otherwise. Control can be direct or indirect. Your licenses are all the licenses granted to you for the software under these terms. Use means anything you do with the software requiring one of your licenses."
  },
  "coffe-app/packages/EPPlus.7.5.1/readme.html": {
    "href": "coffe-app/packages/EPPlus.7.5.1/readme.html",
    "title": "EPPlus 7 | coffe-landishi",
    "keywords": "EPPlus 7 Announcement: new license model from version 5 EPPlus has from this new major version changed license from LGPL to Polyform Noncommercial 1.0.0. With the new license EPPlus is still free to use in some cases, but will require a commercial license to be used in a commercial business. This is explained in more detail here. Commercial licenses, which includes support, can be purchased at (https://www.epplussoftware.com/). The source code of EPPlus has moved to a new github repository LicenseContext parameter must be set With the license change EPPlus has a new parameter that needs to be configured. If the LicenseContext is not set, EPPlus will throw a LicenseException (only in debug mode). This is a simple configuration that can be set in a few alternative ways: 1. Via code // If you are a commercial business and have // purchased commercial licenses use the static property // LicenseContext of the ExcelPackage class : ExcelPackage.LicenseContext = LicenseContext.Commercial; // If you use EPPlus in a noncommercial context // according to the Polyform Noncommercial license: ExcelPackage.LicenseContext = LicenseContext.NonCommercial; using(var package = new ExcelPackage(new FileInfo(\"MyWorkbook.xlsx\"))) { } 2. Via appSettings.json { { \"EPPlus\": { \"ExcelPackage\": { \"LicenseContext\": \"Commercial\" //The license context used } } } } 3. Via app/web.config <appSettings> <!--The license context used--> <add key=\"EPPlus:ExcelPackage.LicenseContext\" value=\"NonCommercial\" /> </appSettings> 4. Set the environment variable 'EPPlusLicenseContext' This might be the easiest way of configuring this. Just as above, set the variable to Commercial or NonCommercial depending on your usage. Important! The environment variable should be set at the user or process level. New features in EPPlus 7 * Calculation engine update to support array formulas. https://epplussoftware.com/en/Developers/EPPlus7 * Support for calculating legacy / dynamic array formulas. * Support for intersect operator. * Support for implicit intersection. * Support for array parameters in functions. * Better support for using the colon operator with functions. * Better handling of circular references * 90 new functions * Faster optimized calculation engine with configurable expression caching. * Breaking changes: Updated calculation engine, See [Breaking Changes in EPPlus 7](https://github.com/EPPlusSoftware/EPPlus/wiki/Breaking-Changes-in-EPPlus-7) for more information. * Conditional Formatting improvements * Improved performance, xml is now read and written on load and save. * Cross worksheet support formula support. * Extended styling options for color scales, data bars and icon sets. Breaking Changes See https://github.com/EPPlusSoftware/EPPlus/wiki/Breaking-Changes-in-EPPlus-7 Improved documentation EPPlus 6 has a new web sample site available here: (https://samples.epplussoftware.com/) , Source code is available here: EPPlus.WebSamples There is also a new sample project for four different docker images, EPPlus.DockerSample EPPlus also has two separate sample projects for .NET Core and .NET Framework respectively. There is also an updated developer wiki. The work with improving the documentation will continue, feedback is highly appreciated!"
  },
  "coffe-app/packages/EPPlus.Interfaces.7.5.0/license.html": {
    "href": "coffe-app/packages/EPPlus.Interfaces.7.5.0/license.html",
    "title": "Polyform Noncommercial License 1.0.0 | coffe-landishi",
    "keywords": "Polyform Noncommercial License 1.0.0 https://polyformproject.org/licenses/noncommercial/1.0.0 Acceptance In order to get any license under these terms, you must agree to them as both strict obligations and conditions to all your licenses. Copyright License The licensor grants you a copyright license for the software to do everything you might do with the software that would otherwise infringe the licensor's copyright in it for any permitted purpose. However, you may only distribute the software according to Distribution License and make changes or new works based on the software according to Changes and New Works License. Distribution License The licensor grants you an additional copyright license to distribute copies of the software. Your license to distribute covers distributing the software with changes and new works permitted by Changes and New Works License. Notices You must ensure that anyone who gets a copy of any part of the software from you also gets a copy of these terms or the URL for them above, as well as copies of any plain-text lines beginning with Required Notice: that the licensor provided with the software. For example: Required Notice: Copyright Yoyodyne, Inc. (http://example.com) Changes and New Works License The licensor grants you an additional copyright license to make changes and new works based on the software for any permitted purpose. Patent License The licensor grants you a patent license for the software that covers patent claims the licensor can license, or becomes able to license, that you would infringe by using the software. Noncommercial Purposes Any noncommercial purpose is a permitted purpose. Personal Uses Personal use for research, experiment, and testing for the benefit of public knowledge, personal study, private entertainment, hobby projects, amateur pursuits, or religious observance, without any anticipated commercial application, is use for a permitted purpose. Noncommercial Organizations Use by any charitable organization, educational institution, public research organization, public safety or health organization, environmental protection organization, or government institution is use for a permitted purpose regardless of the source of funding or obligations resulting from the funding. Fair Use You may have \"fair use\" rights for the software under the law. These terms do not limit them. No Other Rights These terms do not allow you to sublicense or transfer any of your licenses to anyone else, or prevent the licensor from granting licenses to anyone else. These terms do not imply any other licenses. Patent Defense If you make any written claim that the software infringes or contributes to infringement of any patent, your patent license for the software granted under these terms ends immediately. If your company makes such a claim, your patent license ends immediately for work on behalf of your company. Violations The first time you are notified in writing that you have violated any of these terms, or done anything with the software not covered by your licenses, your licenses can nonetheless continue if you come into full compliance with these terms, and take practical steps to correct past violations, within 32 days of receiving notice. Otherwise, all your licenses end immediately. No Liability As far as the law allows, the software comes as is, without any warranty or condition, and the licensor will not be liable to you for any damages arising out of these terms or the use or nature of the software, under any kind of legal claim. Definitions The licensor is the individual or entity offering these terms, and the software is the software the licensor makes available under these terms. You refers to the individual or entity agreeing to these terms. Your company is any legal entity, sole proprietorship, or other kind of organization that you work for, plus all organizations that have control over, are under the control of, or are under common control with that organization. Control means ownership of substantially all the assets of an entity, or the power to direct its management and policies by vote, contract, or otherwise. Control can be direct or indirect. Your licenses are all the licenses granted to you for the software under these terms. Use means anything you do with the software requiring one of your licenses."
  },
  "coffe-app/packages/EPPlus.Interfaces.7.5.0/readme.html": {
    "href": "coffe-app/packages/EPPlus.Interfaces.7.5.0/readme.html",
    "title": "EPPlus.Interfaces | coffe-landishi",
    "keywords": "EPPlus.Interfaces Interfaces used by EPPlus for drawing operations like imaging and text measuring."
  },
  "coffe-app/packages/EPPlus.System.Drawing.7.5.0/license.html": {
    "href": "coffe-app/packages/EPPlus.System.Drawing.7.5.0/license.html",
    "title": "Polyform Noncommercial License 1.0.0 | coffe-landishi",
    "keywords": "Polyform Noncommercial License 1.0.0 https://polyformproject.org/licenses/noncommercial/1.0.0 Acceptance In order to get any license under these terms, you must agree to them as both strict obligations and conditions to all your licenses. Copyright License The licensor grants you a copyright license for the software to do everything you might do with the software that would otherwise infringe the licensor's copyright in it for any permitted purpose. However, you may only distribute the software according to Distribution License and make changes or new works based on the software according to Changes and New Works License. Distribution License The licensor grants you an additional copyright license to distribute copies of the software. Your license to distribute covers distributing the software with changes and new works permitted by Changes and New Works License. Notices You must ensure that anyone who gets a copy of any part of the software from you also gets a copy of these terms or the URL for them above, as well as copies of any plain-text lines beginning with Required Notice: that the licensor provided with the software. For example: Required Notice: Copyright Yoyodyne, Inc. (http://example.com) Changes and New Works License The licensor grants you an additional copyright license to make changes and new works based on the software for any permitted purpose. Patent License The licensor grants you a patent license for the software that covers patent claims the licensor can license, or becomes able to license, that you would infringe by using the software. Noncommercial Purposes Any noncommercial purpose is a permitted purpose. Personal Uses Personal use for research, experiment, and testing for the benefit of public knowledge, personal study, private entertainment, hobby projects, amateur pursuits, or religious observance, without any anticipated commercial application, is use for a permitted purpose. Noncommercial Organizations Use by any charitable organization, educational institution, public research organization, public safety or health organization, environmental protection organization, or government institution is use for a permitted purpose regardless of the source of funding or obligations resulting from the funding. Fair Use You may have \"fair use\" rights for the software under the law. These terms do not limit them. No Other Rights These terms do not allow you to sublicense or transfer any of your licenses to anyone else, or prevent the licensor from granting licenses to anyone else. These terms do not imply any other licenses. Patent Defense If you make any written claim that the software infringes or contributes to infringement of any patent, your patent license for the software granted under these terms ends immediately. If your company makes such a claim, your patent license ends immediately for work on behalf of your company. Violations The first time you are notified in writing that you have violated any of these terms, or done anything with the software not covered by your licenses, your licenses can nonetheless continue if you come into full compliance with these terms, and take practical steps to correct past violations, within 32 days of receiving notice. Otherwise, all your licenses end immediately. No Liability As far as the law allows, the software comes as is, without any warranty or condition, and the licensor will not be liable to you for any damages arising out of these terms or the use or nature of the software, under any kind of legal claim. Definitions The licensor is the individual or entity offering these terms, and the software is the software the licensor makes available under these terms. You refers to the individual or entity agreeing to these terms. Your company is any legal entity, sole proprietorship, or other kind of organization that you work for, plus all organizations that have control over, are under the control of, or are under common control with that organization. Control means ownership of substantially all the assets of an entity, or the power to direct its management and policies by vote, contract, or otherwise. Control can be direct or indirect. Your licenses are all the licenses granted to you for the software under these terms. Use means anything you do with the software requiring one of your licenses."
  },
  "coffe-app/packages/EPPlus.System.Drawing.7.5.0/readme.html": {
    "href": "coffe-app/packages/EPPlus.System.Drawing.7.5.0/readme.html",
    "title": "EPPlus.System.Drawing | coffe-landishi",
    "keywords": "EPPlus.System.Drawing Adds support for Drawing operations using System.Drawing.Common for EPPlus. Used for operations like imaging and text measure."
  },
  "coffe-app/packages/Microsoft.Bcl.AsyncInterfaces.9.0.0/PACKAGE.html": {
    "href": "coffe-app/packages/Microsoft.Bcl.AsyncInterfaces.9.0.0/PACKAGE.html",
    "title": "| coffe-landishi",
    "keywords": "About As of C# 8, the C# language has support for producing and consuming asynchronous iterators. The library types in support of those features are available in .NET Core 3.0 and newer as well as in .NET Standard 2.1. This library provides the necessary definitions of those types to support these language features on .NET Framework and on .NET Standard 2.0. This library is not necessary nor recommended when targeting versions of .NET that include the relevant support. Key Features Enables the use of C# async iterators on older .NET platforms How to Use using System; using System.Collections.Generic; using System.Threading.Tasks; internal static class Program { private static async Task Main() { Console.WriteLine(\"Starting...\"); await foreach (var value in GetValuesAsync()) { Console.WriteLine(value); } Console.WriteLine(\"Finished!\"); static async IAsyncEnumerable<int> GetValuesAsync() { for (int i = 0; i < 10; i++) { await Task.Delay(TimeSpan.FromSeconds(1)); yield return i; } } } } Main Types The main types provided by this library are: IAsyncEnumerable<T> IAsyncEnumerator<T> IAsyncDisposable<T> Additional Documentation C# Feature Specification Walkthrough article Feedback & Contributing Microsoft.Bcl.AsyncInterfaces is released as open source under the MIT license. Bug reports and contributions are welcome at the GitHub repository."
  },
  "coffe-app/packages/Microsoft.IO.RecyclableMemoryStream.3.0.1/README.html": {
    "href": "coffe-app/packages/Microsoft.IO.RecyclableMemoryStream.3.0.1/README.html",
    "title": "Microsoft.IO.RecyclableMemoryStream | coffe-landishi",
    "keywords": "Microsoft.IO.RecyclableMemoryStream A library to provide pooling for .NET MemoryStream objects to improve application performance, especially in the area of garbage collection. Get Started Install the latest version from NuGet Install-Package Microsoft.IO.RecyclableMemoryStream Purpose Microsoft.IO.RecyclableMemoryStream is a MemoryStream replacement that offers superior behavior for performance-critical systems. In particular it is optimized to do the following: Eliminate Large Object Heap allocations by using pooled buffers Incur far fewer gen 2 GCs, and spend far less time paused due to GC Avoid memory leaks by having a bounded pool size Avoid memory fragmentation Allow for multiple ways to read and write data that will avoid extraneous allocations Provide excellent debuggability and logging Provide metrics for performance tracking Features The semantics are close to the original System.IO.MemoryStream implementation, and is intended to be a drop-in replacement as much as possible. Rather than pooling the streams themselves, the underlying buffers are pooled. This allows you to use the simple Dispose pattern to release the buffers back to the pool, as well as detect invalid usage patterns (such as reusing a stream after it’s been disposed). RecyclableMemoryStreamManager is thread-safe (streams themselves are inherently NOT thread safe). Implementation of IBufferWrite<byte>. Support for enormous streams through abstracted buffer chaining. Extensive support for newer memory-related types like Span<byte>, ReadOnlySpan<byte>, ReadOnlySequence<byte>, and Memory<byte>. Each stream can be tagged with an identifying string that is used in logging - helpful when finding bugs and memory leaks relating to incorrect pool use. Debug features like recording the call stack of the stream allocation to track down pool leaks Maximum free pool size to handle spikes in usage without using too much memory. Flexible and adjustable limits to the pooling algorithm. Metrics tracking and events so that you can see the impact on the system. Build Targets At least MSBuild 16.8 is required to build the code. You get this with Visual Studio 2019. Supported build targets in v2.0 are: net462, netstandard2.0, netstandard2.1, and netcoreapp2.1 (net40, net45, net46 and netstandard1.4 were deprecated). Starting with v2.1, net5.0 target has been added. Testing A minimum of .NET 5.0 is required for executing the unit tests. Requirements: NUnit test adapter (VS Extension) Be sure to set the default processor architecture for tests to x64 (or the giant allocation test will fail) Benchmark tests The results are available here Change Log Read the change log here. How It Works RecyclableMemoryStream improves GC performance by ensuring that the larger buffers used for the streams are put into the gen 2 heap and stay there forever. This should cause full collections to happen less frequently. If you pick buffer sizes above 85,000 bytes, then you will ensure these are placed on the large object heap, which is touched even less frequently by the garbage collector. The RecyclableMemoryStreamManager class maintains two separate pools of objects: Small Pool - Holds small buffers (of configurable size). Used by default for all normal read/write operations. Multiple small buffers are chained together in the RecyclableMemoryStream class and abstracted into a single stream. Large Pool - Holds large buffers, which are only used when you must have a single, contiguous buffer, such as when you plan to call GetBuffer(). It is possible to create streams larger than is possible to be represented by a single buffer because of .NET's array size limits. A RecyclableMemoryStream starts out by using a small buffer, chaining additional ones as the stream capacity grows. Should you ever call GetBuffer() and the length is greater than a single small buffer's capacity, then the small buffers are converted to a single large buffer. You can also request a stream with an initial capacity; if that capacity is larger than the small pool block size, multiple blocks will be chained unless you call an overload with asContiguousBuffer set to true, in which case a single large buffer will be assigned from the start. If you request a capacity larger than the maximum poolable size, you will still get a stream back, but the buffers will not be pooled. (Note: This is not referring to the maximum array size. You can limit the poolable buffer sizes in RecyclableMemoryStreamManager) There are two versions of the large pool: Linear (default) - You specify a multiple and a maximum size, and an array of buffers, from size (1 * multiple), (2 * multiple), (3 * multiple), ... maximum is created. For example, if you specify a multiple of 1 MB and maximum size of 8 MB, then you will have an array of length 8. The first slot will contain 1 MB buffers, the second slot 2 MB buffers, and so on. Exponential - Instead of linearly growing, the buffers double in size for each slot. For example, if you specify a multiple of 256KB, and a maximum size of 8 MB, you will have an array of length 6, the slots containing buffers of size 256KB, 512KB, 1MB, 2MB, 4MB, and 8MB. Which one should you use? That depends on your usage pattern. If you have an unpredictable large buffer size, perhaps the linear one will be more suitable. If you know that a longer stream length is unlikely, but you may have a lot of streams in the smaller size, picking the exponential version could lead to less overall memory usage (which was the reason this form was added). Buffers are created, on demand, the first time they are requested and nothing suitable already exists in the pool. After use, these buffers will be returned to the pool through the RecyclableMemoryStream's Dispose method. When that return happens, the RecyclableMemoryStreamManager will use the properties MaximumFreeSmallPoolBytes and MaximumFreeLargePoolBytes to determine whether to put those buffers back in the pool, or let them go (and thus be garbage collected). It is through these properties that you determine how large your pool can grow. If you set these to 0, you can have unbounded pool growth, which is essentially indistinguishable from a memory leak. For every application, you must determine through analysis and experimentation the appropriate balance between pool size and garbage collection. If you forget to call a stream's Dispose method, this could cause a memory leak. To help you prevent this, each stream has a finalizer that will be called by the CLR once there are no more references to the stream. This finalizer will raise an event or log a message about the leaked stream. Note that for performance reasons, the buffers are not ever pre-initialized or zeroed-out. It is your responsibility to ensure their contents are valid and safe to use buffer recycling. If you want to avoid accidental data leakage, you can set ZeroOutBuffer to true. This will zero out the buffers on allocation and before returning them to the pool. Be aware of the performance implications. Usage You can jump right in with no fuss by just doing a simple replacement of MemoryStream with something like this: class Program { private static readonly RecyclableMemoryStreamManager manager = new RecyclableMemoryStreamManager(); static void Main(string[] args) { var sourceBuffer = new byte[] { 0, 1, 2, 3, 4, 5, 6, 7 }; using (var stream = manager.GetStream()) { stream.Write(sourceBuffer, 0, sourceBuffer.Length); } } } IMPORTANT Note that RecyclableMemoryStreamManager should be declared once and it will live for the entire process lifetime. It is perfectly fine to use multiple pools if you desire, especially if you want to configure them differently. To facilitate easier debugging, you can optionally provide a string tag, which serves as a human-readable identifier for the stream. This can be something like “ClassName.MethodName”, but it can be whatever you want. Each stream also has a GUID to provide absolute identity if needed, but the tag is usually sufficient. using (var stream = manager.GetStream(\"Program.Main\")) { stream.Write(sourceBuffer, 0, sourceBuffer.Length); } You can also provide an existing buffer. It’s important to note that the data from this buffer will be copied into a buffer owned by the pool: var stream = manager.GetStream(\"Program.Main\", sourceBuffer, 0, sourceBuffer.Length); You can also change the parameters of the pool itself: var options = new RecyclableMemoryStreamManager.Options() { BlockSize = 1024, LargeBufferMultiple = 1024 * 1024, MaximumBufferSize = 16 * 1024 * 1024, GenerateCallStacks = true, AggressiveBufferReturn = true, MaximumLargePoolFreeBytes = 16 * 1024 * 1024 * 4, MaximumSmallPoolFreeBytes = 100 * 1024, }; var manager = new RecyclableMemoryStreamManager(options); You should usually set at least BlockSize, LargeBufferMultiple, MaximumBufferSize, MaximumLargePoolFreeBytes, and MaximumSmallPoolFreeBytes because their appropriate values are highly dependent on the application. Usage Guidelines While this library strives to be very general and not impose too many restraints on how you use it, its purpose is to reduce the cost of garbage collections incurred by frequent large allocations. Thus, there are some general guidelines for usage that may be useful to you: Set the BlockSize, LargeBufferMultiple, MaximumBufferSize, MaximumLargePoolFreeBytes and MaximumSmallPoolFreeBytes properties to reasonable values for your application and resource requirements. Important!: If you do not set MaximumFreeLargePoolBytes and MaximumFreeSmallPoolBytes there is the possibility for unbounded memory growth! Always dispose of each stream exactly once. Most applications should not call ToArray and should avoid calling GetBuffer if possible. Instead, use GetReadOnlySequence for reading and the IBufferWriter methods GetSpan\\GetMemory with Advance for writing. There are also miscellaneous CopyTo and WriteTo methods that may be convenient. The point is to avoid creating unnecessary GC pressure where possible. Experiment to find the appropriate settings for your scenario. A working knowledge of the garbage collector is a very good idea before you try to optimize your scenario with this library. An article such as Garbage Collection, or a book like Writing High-Performance .NET Code will help you understand the design principles of this library. When configuring the options, consider questions such as these: What is the distribution of stream lengths that I expect? How many streams will be in use at one time? Is GetBuffer called a lot? How much use of large pool buffers will I need? How resilient to spikes in activity do I need to be? i.e., How many free bytes should I keep around in case? What are my physical memory limitations on the machines where this will be used? IBufferWriter<byte>: GetMemory, GetSpan, and Advance RecyclableMemoryStream implements IBufferWriter so it can be used for zero-copy encoding and formatting. You can also directly modify the stream contents using GetSpan\\GetMemory with Advance. For instance, writing a BigInteger to a stream: var bigInt = BigInteger.Parse(\"123456789013374299100987654321\"); using (var stream = manager.GetStream()) { Span<byte> buffer = stream.GetSpan(bigInt.GetByteCount()); bigInt.TryWriteBytes(buffer, out int bytesWritten); stream.Advance(bytesWritten); } GetReadOnlySequence GetReadOnlySequence returns a ReadOnlySequence that can be used for zero-copy stream processing. For example, hashing the contents of a stream: using (var stream = manager.GetStream()) using (var sha256Hasher = IncrementalHash.CreateHash(HashAlgorithmName.SHA256)) { foreach (var memory in stream.GetReadOnlySequence()) { sha256Hasher.AppendData(memory.Span); } sha256Hasher.GetHashAndReset(); } GetBuffer and ToArray RecyclableMemoryStream is designed to operate primarily on chained small pool blocks. To access these blocks use GetReadOnlySequence for reading and GetSpan\\GetMemory with Advance for writing. However, if you still want a contiguous buffer for the whole stream there are two APIs which RecyclableMemoryStream overrides from its parent MemoryStream class: GetBuffer - If possible, a reference to the single block will be returned to the caller. If multiple blocks are in use, they will be converted into a single large pool buffer and the data copied into it. In all cases, the caller must use the Length property to determine how much usable data is actually in the returned buffer. If the stream length is longer than the maximum allowable stream size, a single buffer will still be returned, but it will not be pooled. If no possible contiguous buffer can be returned due to .NET array-size limitations, then an OutOfMemoryException will be thrown. ToArray - It looks similar to GetBuffer on the surface, but is actually significantly different. In ToArray the data is always copied into a new array that is exactly the right length for the full contents of the stream. This new buffer is never pooled. Users of this library should consider any call to ToArray to be a bug, as it wipes out many of the benefits of RecyclableMemoryStream completely. However, the method is included for completeness, especially if you are calling other APIs that only take a byte array with no length parameter. An event is logged on all ToArray calls. You can optionally configure the RecyclableStreamManager.ThrowExceptionOnToArray property to disallow calls to RecyclableMemoryStream.ToArray. If this value is set to true, then any calls to ToArray will result in a NotSupportedException. Metrics and Hooks ETW Events RecyclableMemoryStream has an EventSource provider that produces a number of events for tracking behavior and performance. You can use events to debug leaks or subtle problems with pooled stream usage. Name Level Description MemoryStreamCreated Verbose Logged every time a stream object is allocated. Fields: guid, tag, requestedSize, actualSize. MemoryStreamDisposed Verbose Logged every time a stream object is disposed. Fields: guid, tag, allocationStack, disposeStack. MemoryStreamDoubleDispose Critical Logged if a stream is disposed more than once. This indicates a logic error by the user of the stream. Dispose should happen exactly once per stream to avoid resource usage bugs. Fields: guid, tag, allocationStack, disposeStack1, disposeStack2. MemoryStreamFinalized Error Logged if a stream has gone out of scope without being disposed. This indicates a resource leak. Fields: guid, tag, allocationStack. MemoryStreamToArray Verbose Logged whenever ToArray is called. This indicates a potential problem, as calling ToArray goes against the concepts of good memory practice which RecyclableMemoryStream is trying to solve. Fields: guid, tag, stack, size. MemoryStreamManagerInitialized Informational Logged when the RecyclableMemoryStreamManager is initialized. Fields: blockSize, largeBufferMultiple, maximumBufferSize. MemoryStreamNewBlockCreated Verbose Logged whenever a block for the small pool is created. Fields: smallPoolInUseBytes. MemoryStreamNewLargeBufferCreated Verbose Logged whenever a large buffer is allocated. Fields: requiredSize, largePoolInUseBytes. MemoryStreamNonPooledLargeBufferCreated Verbose Logged whenever a buffer is requested that is larger than the maximum pooled size. The buffer is still created and returned to the user, but it can not be re-pooled. Fields: guid, tag, requiredSize, allocationStack. MemoryStreamDiscardBuffer Warning Logged whenever a buffer is discarded rather than put back in the pool. Fields: guid, tag, bufferType (Small, Large), reason (TooLarge, EnoughFree). MemoryStreamOverCapacity Error Logged whenever an attempt is made to set the capacity of the stream beyond the limits of RecyclableMemoryStreamManager.MaximumStreamCapacity, if such a limit is set. Fields: guid, tag, requestedCapacity, maxCapacity, allocationStack. Event Hooks In addition to the logged ETW events, there are a number of .NET event hooks on RecyclableMemoryStreamManager that you can use as triggers for your own custom actions: Name Description BlockCreated A new small pool block has been allocated. BufferDiscarded A buffer has been refused re-entry to the pool and given over to the garbage collector. LargeBufferCreated A large buffer has been allocated. StreamCreated A new stream has been created. StreamDisposed A stream has been disposed. StreamDoubleDisposed A stream has been disposed twice, indicating an error. StreamFinalized A stream has been finalized, which means it was never disposed before it went out of scope. StreamLength Reports the stream's length upon disposal. Can allow you to track stream metrics. StreamConvertedToArray Someone called ToArray on a stream. StreamOverCapacity An attempt was made to expand beyond the maximum capacity allowed by the pool manager. UsageReport Provides stats on pool usage for metrics tracking. Debugging Problems Once you start introducing re-usable resources like the pooled buffers in RecyclableMemoryStream, you are taking some of the duties of the CLR away from it and reserving them for yourself. This can be error-prone. See the Usage section above for some guidelines on making your usage of this library successful. There are a number of features that will help you debug usage of these streams. Stream Identification Each stream is assigned a unique GUID and, optionally, a tag. The GUID is unique for each stream object and serves to identify that stream throughout its lifetime. A tag is an optional, arbitrary string assigned by the caller when a stream is requested. This can be a class name, function name, or some other meaningful string that can help you identify the source of the stream's usage. Note that multiple streams will contain the same tag. They identify where in your code the stream originated; they are not unique stream identifiers. Callstack Recording If you set the GenerateCallStacks property on RecyclableMemoryStreamManager to true, then major operations on the stream, such as allocation and disposal, will record the call stack of those method calls. These will be reported in ETW events in the event of detected programming errors such as double-dispose or finalization. Turning this feature on causes a very significant negative performance impact, so should only be done when actively investigating a problem. Double-Dispose Protection If Dispose is called twice on the same stream, an event is logged with the relevant stream's information. If GenerateCallStacks is turned on, this will include the call stacks for allocation and both disposals. Non-Dispose Detection If Dispose is never called for a stream, the finalizer will eventually be called by the CLR, and an event will be logged with relevant stream information, including the allocation stack, if enabled. Buffers for finalized streams are lost to the pool, and this should be considered a bug. Concurrency Concurrent use of RecyclableMemoryStream objects is not supported under any circumstances. However, RecyclableMemoryStreamManager is thread-safe and can be used to retrieve streams in a multi-threading scenario. ETW Events Use an ETW event monitor such as PerfView to collect and analyze ETW events. Many of these events contain helpful clues about the stream in question, including its tag, guid, and stacks (if enabled). Reference Read the API documentation here. License This library is released under the MIT license. Support Check the support policy here"
  },
  "coffe-app/packages/System.IO.Pipelines.9.0.0/PACKAGE.html": {
    "href": "coffe-app/packages/System.IO.Pipelines.9.0.0/PACKAGE.html",
    "title": "| coffe-landishi",
    "keywords": "About A library designed to make it easier to do high-performance I/O. Apps that parse streaming data are composed of boilerplate code having many specialized and unusual code flows. The boilerplate and special case code is complex and difficult to maintain. System.IO.Pipelines was architected to: Have high performance parsing streaming data. Reduce code complexity. Key Features Single producer/single consumer byte buffer management. Reduction in code complexity and boilerplate code associated with I/O operations. How to Use Check the System.IO.Pipelines in .NET article for a full example. Main Types The main types provided by this library are: System.IO.Pipelines.Pipe System.IO.Pipelines.PipeWriter System.IO.Pipelines.PipeReader Additional Documentation Conceptual documentation API documentation Feedback & Contributing System.IO.Pipelines is released as open source under the MIT license. Bug reports and contributions are welcome at the GitHub repository."
  },
  "coffe-app/packages/System.Text.Encodings.Web.9.0.0/PACKAGE.html": {
    "href": "coffe-app/packages/System.Text.Encodings.Web.9.0.0/PACKAGE.html",
    "title": "| coffe-landishi",
    "keywords": "About Provides types for encoding and escaping strings for use in JavaScript, HTML, and URLs. This package is essential for protecting web applications against cross-site scripting (XSS) attacks by safely encoding text, and it offers extensive support for Unicode, allowing fine-grained control over which characters are encoded and which are left unescaped. Key Features Safe encoders for HTML, JavaScript, and URL strings. Extensible to support custom encoding scenarios, including the ability to specify Unicode ranges. Helps prevent cross-site scripting (XSS) vulnerabilities. Flexible Unicode encoding with support for specifying individual or predefined ranges to cover broader sets of characters, including options to avoid escaping specific language character sets. How to Use Encoding HTML, JavaScript, and URLs using System.Text.Encodings.Web; string unsafeString = \"<script>alert('XSS Attack!');</script>\"; // HTML encode the string to safely display it on a web page. string safeHtml = HtmlEncoder.Default.Encode(unsafeString); Console.WriteLine(safeHtml); // &lt;script&gt;alert(&#x27;XSS Attack!&#x27;);&lt;/script&gt; // JavaScript encode the string to safely include it in a JavaScript context. string safeJavaScript = JavaScriptEncoder.Default.Encode(unsafeString); Console.WriteLine(safeJavaScript); // \\u003Cscript\\u003Ealert(\\u0027XSS Attack!\\u0027);\\u003C/script\\u003E string urlPart = \"user input with spaces and & symbols\"; // URL encode the string to safely include it in a URL. string encodedUrlPart = UrlEncoder.Default.Encode(urlPart); Console.WriteLine(encodedUrlPart); // user%20input%20with%20spaces%20and%20%26%20symbols Custom Encoding Scenario with Specific Unicode Ranges using System.Text.Encodings.Web; using System.Text.Unicode; TextEncoderSettings customEncoderSettings = new TextEncoderSettings(); customEncoderSettings.AllowCharacters('!', '*', '-', '.', '_', '~'); // RFC 3986 unreserved characters customEncoderSettings.AllowRange(new UnicodeRange('a', 26)); customEncoderSettings.AllowRange(new UnicodeRange('A', 26)); customEncoderSettings.AllowRange(new UnicodeRange('0', 10)); // Create a URL encoder with the custom settings UrlEncoder customUrlEncoder = UrlEncoder.Create(customEncoderSettings); string customUrlPart = \"custom data: (@123!)\"; // By default, the symbols '(', ')', and '@' are not encoded string defaultEncoded = UrlEncoder.Default.Encode(customUrlPart); Console.WriteLine(defaultEncoded); // custom%20data%3A%20(@123!) // Now, the symbols '(', ')', and '@' are also encoded string customEncoded = customUrlEncoder.Encode(customUrlPart); Console.WriteLine(customEncoded); // custom%20data%3A%20%28%40123!%29 Serialization with Specific Unicode Character Sets By default Cyrillic characters are encoded as Unicode escape sequences in JSON. { \"Date\": \"2019-08-01T00:00:00-07:00\", \"TemperatureCelsius\": 25, \"Summary\": \"\\u0436\\u0430\\u0440\\u043A\\u043E\" } This can be customized by providing a custom JavaScriptEncoder to JsonSerializerOptions: JsonSerializerOptions options = new JsonSerializerOptions { Encoder = JavaScriptEncoder.Create(UnicodeRanges.BasicLatin, UnicodeRanges.Cyrillic), WriteIndented = true }; jsonString = JsonSerializer.Serialize(weatherForecast, options1); { \"Date\": \"2019-08-01T00:00:00-07:00\", \"TemperatureCelsius\": 25, \"Summary\": \"жарко\" } More information about this can be found in the How to customize character encoding with System.Text.Json article. Main Types The main types provided by this library are: System.Text.Encodings.Web.HtmlEncoder System.Text.Encodings.Web.JavaScriptEncoder System.Text.Encodings.Web.UrlEncoder System.Text.Encodings.Web.TextEncoder System.Text.Encodings.Web.TextEncoderSettings System.Text.Unicode.UnicodeRange System.Text.Unicode.UnicodeRanges Additional Documentation API documentation Feedback & Contributing System.Text.Encodings.Web is released as open source under the MIT license. Bug reports and contributions are welcome at the GitHub repository."
  },
  "coffe-app/packages/System.Text.Json.9.0.0/PACKAGE.html": {
    "href": "coffe-app/packages/System.Text.Json.9.0.0/PACKAGE.html",
    "title": "| coffe-landishi",
    "keywords": "About Provides high-performance and low-allocating types that serialize objects to JavaScript Object Notation (JSON) text and deserialize JSON text to objects, with UTF-8 support built-in. Also provides types to read and write JSON text encoded as UTF-8, and to create an in-memory document object model (DOM), that is read-only, for random access of the JSON elements within a structured view of the data. Key Features High-performance reader and writer types for UTF-8 encoded JSON. A fully-featured JSON serializer for .NET types using reflection or source generated contracts. A high-performance read-only JSON DOM (JsonDocument) and a mutable DOM that interoperates with the serializer (JsonNode). Built-in support for async serialization, including IAsyncEnumerable support. Fully customizable contract model for serializable types. How to Use The System.Text.Json library is built-in as part of the shared framework in .NET Runtime. The package can be installed when you need to use the most recent version in older target frameworks. Serialization: using System; using System.Text.Json; WeatherForecast forecast = new (DateTimeOffset.Now, 26.6f, \"Sunny\"); var serialized = JsonSerializer.Serialize(forecast); Console.WriteLine(serialized); // {\"Date\":\"2023-08-02T16:01:20.9025406+00:00\",\"TemperatureCelsius\":26.6,\"Summary\":\"Sunny\"} var forecastDeserialized = JsonSerializer.Deserialize<WeatherForecast>(serialized); Console.WriteLine(forecast == forecastDeserialized); // True public record WeatherForecast(DateTimeOffset Date, float TemperatureCelsius, string? Summary); Serialization using the source generator: using System.Text.Json; using System.Text.Json.Serialization; WeatherForecast forecast = new (DateTimeOffset.Now, 26.6f, \"Sunny\"); var serialized = JsonSerializer.Serialize(forecast, SourceGenerationContext.Default.WeatherForecast); Console.WriteLine(serialized); // {\"Date\":\"2023-08-02T16:01:20.9025406+00:00\",\"TemperatureCelsius\":26.6,\"Summary\":\"Sunny\"} var forecastDeserialized = JsonSerializer.Deserialize<WeatherForecast>(serialized, SourceGenerationContext.Default.WeatherForecast); Console.WriteLine(forecast == forecastDeserialized); // True public record WeatherForecast(DateTimeOffset Date, float TemperatureCelsius, string? Summary); [JsonSourceGenerationOptions(WriteIndented = true)] [JsonSerializable(typeof(WeatherForecast))] internal partial class SourceGenerationContext : JsonSerializerContext { } Using the JSON DOM: using System; using System.Text.Json; using System.Text.Json.Nodes; string jsonString = @\"{ \"\"Date\"\": \"\"2019-08-01T00:00:00\"\", \"\"Temperature\"\": 25, \"\"Summary\"\": \"\"Hot\"\", \"\"DatesAvailable\"\": [ \"\"2019-08-01T00:00:00\"\", \"\"2019-08-02T00:00:00\"\" ], \"\"TemperatureRanges\"\": { \"\"Cold\"\": { \"\"High\"\": 20, \"\"Low\"\": -10 }, \"\"Hot\"\": { \"\"High\"\": 60, \"\"Low\"\": 20 } } } \"; JsonNode forecastNode = JsonNode.Parse(jsonString)!; // Get value from a JsonNode. JsonNode temperatureNode = forecastNode[\"Temperature\"]!; Console.WriteLine($\"Type={temperatureNode.GetType()}\"); Console.WriteLine($\"JSON={temperatureNode.ToJsonString()}\"); //output: //Type = System.Text.Json.Nodes.JsonValue`1[System.Text.Json.JsonElement] //JSON = 25 // Get a typed value from a JsonNode. int temperatureInt = (int)forecastNode[\"Temperature\"]!; Console.WriteLine($\"Value={temperatureInt}\"); //output: //Value=25 // Get a typed value from a JsonNode by using GetValue<T>. temperatureInt = forecastNode[\"Temperature\"]!.GetValue<int>(); Console.WriteLine($\"TemperatureInt={temperatureInt}\"); //output: //Value=25 // Get a JSON object from a JsonNode. JsonNode temperatureRanges = forecastNode[\"TemperatureRanges\"]!; Console.WriteLine($\"Type={temperatureRanges.GetType()}\"); Console.WriteLine($\"JSON={temperatureRanges.ToJsonString()}\"); //output: //Type = System.Text.Json.Nodes.JsonObject //JSON = { \"Cold\":{ \"High\":20,\"Low\":-10},\"Hot\":{ \"High\":60,\"Low\":20} } // Get a JSON array from a JsonNode. JsonNode datesAvailable = forecastNode[\"DatesAvailable\"]!; Console.WriteLine($\"Type={datesAvailable.GetType()}\"); Console.WriteLine($\"JSON={datesAvailable.ToJsonString()}\"); //output: //datesAvailable Type = System.Text.Json.Nodes.JsonArray //datesAvailable JSON =[\"2019-08-01T00:00:00\", \"2019-08-02T00:00:00\"] // Get an array element value from a JsonArray. JsonNode firstDateAvailable = datesAvailable[0]!; Console.WriteLine($\"Type={firstDateAvailable.GetType()}\"); Console.WriteLine($\"JSON={firstDateAvailable.ToJsonString()}\"); //output: //Type = System.Text.Json.Nodes.JsonValue`1[System.Text.Json.JsonElement] //JSON = \"2019-08-01T00:00:00\" // Get a typed value by chaining references. int coldHighTemperature = (int)forecastNode[\"TemperatureRanges\"]![\"Cold\"]![\"High\"]!; Console.WriteLine($\"TemperatureRanges.Cold.High={coldHighTemperature}\"); //output: //TemperatureRanges.Cold.High = 20 // Parse a JSON array JsonNode datesNode = JsonNode.Parse(@\"[\"\"2019-08-01T00:00:00\"\",\"\"2019-08-02T00:00:00\"\"]\")!; JsonNode firstDate = datesNode[0]!.GetValue<DateTime>(); Console.WriteLine($\"firstDate={ firstDate}\"); //output: //firstDate = \"2019-08-01T00:00:00\" Using the low-level JSON reader/writer types using System; using System.IO; using System.Text; using System.Text.Json; var writerOptions = new JsonWriterOptions { Indented = true }; using var stream = new MemoryStream(); using var writer = new Utf8JsonWriter(stream, writerOptions); writer.WriteStartObject(); writer.WriteString(\"date\", DateTimeOffset.Parse(\"8/2/2023 9:00 AM\")); writer.WriteNumber(\"temp\", 42); writer.WriteEndObject(); writer.Flush(); var jsonBytes = stream.ToArray(); string json = Encoding.UTF8.GetString(jsonBytes); Console.WriteLine(json); // { // \"date\": \"2023-08-02T09:00:00+00:00\" // \"temp\": 42 // } var readerOptions = new JsonReaderOptions { AllowTrailingCommas = true, CommentHandling = JsonCommentHandling.Skip }; var reader = new Utf8JsonReader(jsonBytes, readerOptions); while (reader.Read()) { Console.Write(reader.TokenType); switch (reader.TokenType) { case JsonTokenType.PropertyName: case JsonTokenType.String: { string? text = reader.GetString(); Console.Write(\" \"); Console.Write(text); break; } case JsonTokenType.Number: { int intValue = reader.GetInt32(); Console.Write(\" \"); Console.Write(intValue); break; } // Other token types elided for brevity } Console.WriteLine(); } // StartObject // PropertyName date // String 2023-08-02T09:00:00+00:00 // PropertyName temp // Number 42 // EndObject Main Types The main types provided by this library are: System.Text.Json.Utf8JsonWriter System.Text.Json.Utf8JsonReader System.Text.Json.JsonSerializer System.Text.Json.JsonConverter System.Text.Json.JsonDocument System.Text.Json.Nodes.JsonNode System.Text.Json.Serialization.Metadata.JsonTypeInfo Additional Documentation Conceptual documentation API documentation Related Packages Lightweight data formats abstraction: System.Memory.Data Serialization of HttpContent: System.Net.Http.Json Feedback & Contributing System.Text.Json is released as open source under the MIT license. Bug reports and contributions are welcome at the GitHub repository."
  },
  "docs/getting-started.html": {
    "href": "docs/getting-started.html",
    "title": "Getting Started | coffe-landishi",
    "keywords": "Getting Started"
  },
  "docs/introduction.html": {
    "href": "docs/introduction.html",
    "title": "Introduction | coffe-landishi",
    "keywords": "Introduction"
  },
  "index.html": {
    "href": "index.html",
    "title": "This is the HOMEPAGE. | coffe-landishi",
    "keywords": "This is the HOMEPAGE. Refer to Markdown for how to write markdown files. Quick Start Notes: Add images to the images folder if the file is referencing an image."
  }
}